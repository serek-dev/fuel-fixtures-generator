<?php

declare(strict_types=1);

namespace Integration\Generator;

use Mock\ModelImitation;
use Mock\TwigEngine;
use PHPUnit\Framework\TestCase;
use Stwarog\FuelFixturesGenerator\Config;
use Stwarog\FuelFixturesGenerator\FixtureFactory;
use Stwarog\FuelFixturesGenerator\FuelAwareNameGenerator;
use Stwarog\FuelFixturesGenerator\Renderer\Engine;
use Stwarog\FuelFixturesGenerator\Renderer\File;
use Stwarog\FuelFixturesGenerator\Renderer\Service;

use const PHP_EOL;

/** @covers \Stwarog\FuelFixturesGenerator\Renderer\Service */
final class ServiceTest extends TestCase
{
    private const NAMESPACE = 'Tests\Fixtures';
    private const STORAGE_PATH = 'tests/output/';
    private const TEMPLATE = 'fixture.twig';

    private const REQUIRED_STATES = ['basic', 'belongs_to', 'has_one'];
    private const RANDOMIZABLE_FIELDS = ['status', 'body'];
    private const GET_STATES = ['basic' => false, 'belongs_to' => true, 'has_one' => true]; # should be as referenced

    private Service $service;

    public static function tearDownAfterClass(): void
    {
        $path = self::STORAGE_PATH . 'MockModelImitationFixture.php';

        if (file_exists($path)) {
            unlink($path);
        }
        parent::tearDownAfterClass();
    }

    public function testItCreatesNewFileInConfiguredPath(): string
    {
        // When Service is called
        $res = $this->service->generate(ModelImitation::class);

        // Then file name that is present in method output, should be created
        $this->assertFileExists($res['created']);

        return (string)file_get_contents($res['created']);
    }

    /** @depends testItCreatesNewFileInConfiguredPath */
    public function testNameSpaceIsTakenFromConfig(string $output): void
    {
        $this->assertStringContainsString(self::NAMESPACE, $output);
    }

    /** @depends testItCreatesNewFileInConfiguredPath */
    public function testAllRequiredStatesAsDefinedAsConstant(string $output): void
    {
        foreach (self::REQUIRED_STATES as $state) {
            $fullName = sprintf("public const %s = '%s'", strtoupper($state), $state);
            $this->assertStringContainsString($fullName, $output);
        }
    }

    /** @depends testItCreatesNewFileInConfiguredPath */
    public function testGetClassReturnsFullName(string $output): void
    {
        $this->assertStringContainsString('return \Mock\ModelImitation::class;', $output);
    }

    /** @depends testItCreatesNewFileInConfiguredPath */
    public function testGetDefaultsContainsRandomizableFieldsAndNothingMore(string $output): void
    {
        foreach (self::RANDOMIZABLE_FIELDS as $field) {
            $fullName = sprintf('\'%s\' => $this->faker->word, # todo: autogenerated', $field);
            $this->assertStringContainsString($fullName, $output);
            $this->assertTrue(
                substr_count(
                    $output,
                    '$this->faker->word, # todo: autogenerated'
                ) === ($c = count(self::RANDOMIZABLE_FIELDS)
                ),
                'There should be only ' . $c . ' randomizable fields'
            );
        }
    }

    /** @depends testItCreatesNewFileInConfiguredPath */
    public function testGetStatesShouldContainsBasicStateAndTwoReferenceTypes(string $output): void
    {
        foreach (self::GET_STATES as $state => $useReference) {
            $asReference = sprintf('$this->reference(\'%s\', \Tests\Fixtures\ModelImitationFixture::class)', $state);
            $target = !$useReference ? '$this->basic()' : $asReference;
            $fullName = sprintf('self::%s => %s', strtoupper($state), $target);
            $this->assertStringContainsString($fullName, $output);
        }
    }

    /** @depends testItCreatesNewFileInConfiguredPath */
    public function testBasicStateShouldOptinallyCallReferencedFixture(string $output): void
    {
        foreach (self::GET_STATES as $state => $useReference) {
            if (!$useReference) {
                continue;
            }

            $fullName = sprintf(
                '/** @var \Tests\Fixtures\ModelImitationFixture $fixture */
                $fixture = $this->fixture(self::%s);
                $model->%s = $fixture->makeOne([]);',
                strtoupper($state),
                $state
            );

            $normalize = fn(string $s) => str_replace([PHP_EOL, ' '], ['', ''], $s);

            $this->assertStringContainsString($normalize($fullName), $normalize($output));
        }
    }

    protected function setUp(): void
    {
        $config = $this->getConfig();

        $this->service = new Service(
            new FixtureFactory(
                new FuelAwareNameGenerator($config),
                $config
            ),
            $this->getEngine(),
            new File(),
            $config,
        );

        parent::setUp();
    }

    private function getConfig(): Config
    {
        return new class (self::NAMESPACE, self::STORAGE_PATH, self::TEMPLATE) implements Config {
            private string $namespace;
            private string $storagePath;
            private string $template;

            public function __construct(string $namespace, string $storagePath, string $template)
            {
                $this->namespace = $namespace;
                $this->storagePath = $storagePath;
                $this->template = $template;
            }

            public function getNamespace(): string
            {
                return $this->namespace;
            }

            public function storagePath(): string
            {
                return $this->storagePath;
            }

            public function outputTemplate(): string
            {
                return $this->template;
            }
        };
    }

    private function getEngine(): Engine
    {
        return new TwigEngine(__DIR__ . '/../../../resources/');
    }
}
