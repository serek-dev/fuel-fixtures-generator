namespace {{ chunk.namespace }};

use Stwarog\FuelFixtures\Fuel\Factory;

final class {{ chunk.name }} extends Factory
{
    // put your states here
{% for state in chunk.states %}
    public const {{ state.name|upper }} = '{{ state.name }}';
{% endfor %}

    public static function getClass(): string
    {
        return \{{ chunk.class }}::class;
    }

    /** @inheritdoc */
    public function getDefaults(): array
    {
        return [
{% for property in chunk.properties %}
            '{{ property }}' => $this->faker->word, # todo: autogenerated
{% endfor %}
        ];
    }

    /** @inheritdoc */
    public function getStates(): array
    {
        return [
{% for state in chunk.states %}
    {% if state.type == 'callback' %}
            self::{{ state.name|upper }} => $this->{{ state.name }}(),
    {% endif %}
    {% if state.type == 'reference' %}
        self::{{ state.name|upper }} => $this->reference('{{ state.property }}', \{{ chunk.namespace }}{{ state.targetFixture }}::class){{ PHP_EOL }},
    {% endif %}
{% endfor %}
        ];
    }

    private function basic(): callable
    {
        /*
            todo: autogenerated
            This content has been automatically generated and need a review!
            If referenced class contains nested relations like this class,
            Ensure the target Fixture contains 'basic' state and add below status 'basic'

            For example:
            $model->whitelabel_raffle = $this->fixture(self::WHITELABEL_RAFFLE)->with('basic')->makeOne([]);

            You can also use nested states from the fixture, for example CurrencyFixture has states: usd, eur, pln
            It is possible to have such a call here:
            $model->whitelabel_raffle = $this->fixture(self::WHITELABEL_RAFFLE)->with('usd', 'eur')->makeOne([]);
            $model->whitelabel_raffle = $this->fixture(self::WHITELABEL_RAFFLE)->makeOne(['code' => 'usd']);

            Do not use createOne and createMany here! These methods will persist to DB, and we won't to have it
            at this step.

            Also, here we are checking if the relations exists, and conditionally we generate it.
            It's important, because basic will generate the minimal effort entity that can be successfully
            persisted in DB (will all random relations). It is better approach to pass explicit state
            with all desired fields.
        */

        return function (\{{ chunk.class }} $model, array $attributes = []) {
{% for state in chunk.states %}
    {% if state.type == 'reference' %}
        if (empty($model->{{ state.name }})) {
        /** @var \{{ chunk.namespace }}{{ state.targetFixture }} $fixture */
        $fixture = $this->fixture(self::{{ state.name|upper }});
        $model->{{ state.name }} = $fixture->make{{ state.hasMany ? 'Many' : 'One' }}([]);
        }

    {% endif %}
{% endfor %}
        };
    }
}
